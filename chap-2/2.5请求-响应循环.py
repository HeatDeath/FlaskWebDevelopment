#-----------------------------------------------------#
#----------------2.5.1程序和请求上下文----------------#
Flask从客户端接受到请求时，要让视图函数能访问一些对象，这样才能处理请求。
请求对象就是一个很好的例子，请求对象封装了客户端发送的HTTP请求。

Flask为了避免大量可有可无的参数把是凸函数弄得一团糟，
使用上下文临时把某些对象变为全局可访问。

from flask import request
@app.route('/')
def index():
    user_agent=request.headers.get('User-Agent')
    return '<p> Your browser is %s</p>'% user_agent

Flask中有程序上下文和请求上下文

#current_app
程序上下文
当前激活程序的程序实例

#g
程序上下文
处理请求时用作临时存储的对象。每次请求都会重设这个变量

#request
请求上下文
请求对象，封装了客户端发出的HTTP请求中的内容

#session
求情上下文
用户会话，用于储存请求之间需要“记住”的值得词典

Flask在分发请求之前激活（或者推送）程序和请求上下文，
请求处理完成后再将其删除。
程序上下文被推送后，就可以在线程中使用current_app和g变量。
如果使用这些变量时，我们没有激活程序上下文或者请求上下文，就会导致错误

#---------------------------------------------#
#----------------2.5.2请求调度----------------#
程序收到客户端发来的请求时，要找到处理该请求的视图函数
为了完成这个任务，Flask会在程序的URL映射中查找请求的URL
Flask使用app.route修饰器或者非修饰器形势的app.add_url_rule()生成映射

URL映射中的HEAD、OPTIONS、GET是请求方法，由路由器进行处理。
Flask为每个路由器指定了请求方法，这样不同的请求方法发送到相同的URL上时，
会使用不同的视图函数进行处理。

#---------------------------------------------#
#----------------2.5.3请求钩子----------------#
有时在处理请求之前或之后执行代码会很有用
为了避免在每个视图函数中都使用重复的代码，Flask提供了注册通用函数的功能，
注册的函数可在被发分发到视图函数之前或之后被调用

请求钩子使用修饰器实现
#before_first_request:注册一个函数，在处理第一个请求之前运行
#before_request:注册一个函数，在每次请求之前运行
#after_request:注册一个函数，如果没有未处理的异常抛出，在每次请求之后运行
#teardown_request:注册一个函数，即使有未处理的异常抛出，也在每次请求之后运行

请求钩子函数和视图函数之间共享数据一般使用上下文全局变量g。

#-----------------------------------------#
#----------------2.5.4响应----------------#
Flask调用视图函数后，会将其返回值作为响应的内容。
大多数情况下，响应就是一个简单的字符串，作为HTML页面会送客户端。
但HTTP协议需要的不仅是作为请求响应的字符串。
HTTP响应中一个很重要的部分是状态码，Flask默认为200，这个代码表示请求已经被成功处理

如果视图函数返回的响应需要使用不同的状态码，那么可以把数字代码作为第二个返回值，
添加到响应文本之后。例如，下述视图函数返回一个400状态码，表示请求无效：

@app_route('/')
def index():
    return '<h1>Bad Request</h1>',400

视图函数返回的响应还可以接受第三个参数，这是一个由header组成的字典，
可以添加到相应文本中，但一般情况下不需要这么做。

如果不想返回由1个、2个或3个值组成的元组，Flask视图函数还可以返回Response对象。

make_response()函数可以接受1个、2个或3个参数（和视图函数的返回值一样），并返回
一个Response对象。有时我们需要在视图函数中进行这种转换，然后在响应对象上调用各种
方法，进一步设置响应。下面的例子创建了一个响应对象，然后设置了cookie：

from flask import make_response

@app.route('/')
def index():
    response=make_response('<h1>This document carries a cookie!</h1>')
    response.set_cookie('answer','42')
    return response


有一种名为重定向的特殊响应类型。这种响应没有页面文档，只告诉浏览器一个新地址用以
加载新页面。重定向经常在Web表单中使用，状态码302。Flask提供了辅助函数redirect()

from flask import redirect

@app.route('/')
def index():
    return redirect('http://www.exanple.com')


还有一种特殊的响应由abort函数生成，用于处理错误。在下面的例子中，如果URL中动态
参数id对应的用户不存在，就返回状态码404：

from flask import abort

@app.route('user/<id>')
def get_user(id):
    user=load_user(id)
    if not uesr:
        abort(404)
    return '<h1>Hello,%s</h1?'% user.name
注意，abort不会把控制权交还给调用它的函数，而是抛出异常把控制权交给Web服务器

